<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Advanced JGSS Security Programming </title>
<meta name="collection" content="reference">
  
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <meta name="keywords" value="">
  <meta name="description" value="">
  
  <!-- <link rel="stylesheet"  href="index-j1_files/default.css">stopindex
  --> 
  
  <!--
.style1 {
	color: #FF0000;
	font-style: italic;
	font-weight: bold;
}
.style8 {font-size: 12pt}
.style10 {color: #594fbf}
-->

<style type="text/css">

.style1 {
	color: #FF0000;
	font-style: italic;
	font-weight: bold;
}
.style8 {font-size: 12pt}
.style10 {color: #594fbf}

p, li,  ul li { margin-left: 40pt;
                   font-family: Helvetica, Arial, sans-serif;
			    font-size: medium; 
			    }

h2  { margin-left: 40pt;
      margin-top:32pt;
      font-family: Helvetica, Arial, sans-serif;
	 font-size: larger; }
	 
h3	{ font-family: helvetica,arial,sans-serif;
       font-size: medium;
       font-weight: bold; 

	  margin-left: 40pt;
	  }
			    
</style>

  <meta name="author" content="Seema Malkani">
  <meta name="author" content="Seema Malkani"></head>

<body leftmargin="0" topmargin="0" style="background-color: rgb(255, 255, 255);" marginheight="0" marginwidth="0">













<!-- part II -->

 <a name="PART2">
<h2 class="main1">Part II : Secure Communications using the Java SE 6
Security API</h2>

</a>

<p>This part shows you how to build applications that
perform secure communications. The Java SE 6 platform provides three
standard APIs that allow applications to perform secure
communications: The Java Generic Security Service (GSS), the Java SASL API,
and the Java Secure Socket Extension (JSSE). When building an application,
which of these APIs should you use? The answer 
depends on many factors, including requirements of the protocol or
service, deployment infrastructure, and integration with other
security services. For example, if you are building an LDAP client
library, you would need to use the Java SASL API because use of SASL
is part of LDAP's protocol definition. As an other example, if the
service supports SSL, then the client application attempting to access
the service would need to use JSSE.</p>


<h2 class="main1"><a name="JGSS"></a>Exercise 3: Using the Java Generic
Security Service (GSS) API
</h2><br>


<h3>Goal of this exercise:</h3>

<p style="font-family: helvetica,arial,sans-serif;"><br>
The goal of this exercise is to learn how to use the Java GSS API
&nbsp;to perform secure authentication and communication.</p> 

<a name="JGSSBG"></a>
<h3>Background
for this exercise:</h3>

<p> The
Generic Security
Service API provides a uniform C-language interface to access various
security services, such as authentication, message integrity, and
message confidentiality. The Java GSS API provides the corresponding
interface for Java applications.&nbsp; It allows applications to
perform
authentication and establish secure communication with the peer. One of
the most common security service accessed via the GSS-API and Java
GSS-API is Kerberos.</p>

<h3>Resources for this Exercise:</h3>

<ol>
  <li><a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/jgss/tutorials/index.html">The
JAAS and Java GSS-API Tutorials</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc2853.txt">Generic Security
Service API Version 2: Java Bindings (RFC 2853)</a> </li>
  <li>Java GSS javadocs: <a href="http://java.sun.com/j2se/1.5.0/docs/api/org/ietf/jgss/package-summary.html">org.ietf.jgss</a>.
  </li>
</ol>


<h3>Overview
of this Exercise:</h3>


<p><span style="font-family: helvetica,arial,sans-serif;">This exercise
is a client-server application that demonstrates how to communicate
securely using the Java GSS API. The client and server parts first
authenticate to Kerberos, as shown in 
<a href="part1.html#JAAS">Exercise 1</a>. This stores the credentials in the
subject.
The application then executes an action that performs Java GSS
operations (with Kerberos as the underlying GSS mechanism)
inside of a <tt>Subject.doAs</tt> using the subject.
The Java GSS Kerberos mechanism, because it is
executing inside the <tt>doAs</tt>, obtains the Kerberos credentials
from the subject, and uses them to authenticate with the peer
and to exchange messages securely.
</p>

<h3>Steps
to follow:</h3>


<ol>
  <li> Read the following code. This is located in <a href="./src/GssServer.java"><code>src/GssServer.java.</code></a>
    
  <br><br>
    This code fragment defines the action to execute after the
service principal has authenticated to the KDC. It replaces the <tt>MyAction</tt>
of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted
lines. The code first creates an instance of <b><code>GSSManager</code></b>
[line 8], which it uses to obtain its own credentials [line 10-11] and
to create an instance of <b><code>GSSContext</code></b> [line 18]. It
uses this context to perform authentication [the loop between lines
22-34]. Upon completing authentication, it accepts encrypted input from
the client and uses the established security context to decrypt the
data [line 45]. It then uses the security context to encrypt
a reply containing the original input and the date [line 49], and then
sends it back to the client. 
  </li>
</ol>

<p>Code listing for <code>GssServer.java</code>.</p> <br>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>static class GssServerAction implements
PrivilegedExceptionAction {</code> </li>
        <li><code>...</code> </li>
        <li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create server socket for
accepting connections</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;ServerSocket ss = new
ServerSocket(localPort);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get own Kerberos
credentials for accepting connection</code> </li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;GSSManager manager =
GSSManager.getInstance();</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;Oid krb5Oid = new
Oid("1.2.840.113554.1.2.2");</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<b>GSSCredential serverCreds
=
manager.createCredential(null,</b></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>GSSCredential.DEFAULT_LIFETIME,
krb5Oid, GSSCredential.ACCEPT_ONLY);</b></code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (true) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket socket =
ss.accept();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream
inStream = new DataInputStream(socket.getInputStream());</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream
outStream = new DataOutputStream(socket.getOutputStream());</code></li>
        <li><br>
        </li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GSSContext
context = manager.createContext((GSSCredential)serverCreds);</code></strong></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do the context
establishment loop</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] token =
null;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>context.isEstablished()</strong>)
{</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Read token</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token
= new
byte[inStream.readInt()];</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Process
token</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token
= context.acceptSecContext(token, 0, token.length);</code></strong></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Send a
token to the peer if one was generated by acceptSecContext</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Context
established!</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
MessageProp
for use with unwrap (will be set upon return from unwrap)</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageProp prop
= new
MessageProp(0, false);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read token
from client</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = new
byte[inStream.readInt()];</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Unwrap
(decrypt)
token sent by client</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
input =
context.unwrap(token, 0, token.length, prop);</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create new
token
and send to client</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] reply =
...;</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token =
context.wrap(reply, 0, reply.length, prop);</code></strong></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.dispose();</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.close();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;}</code></li>
        <li><code>}</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<ol start="2">
  <li>Compile the sample code. <b><code></code>
    <pre><blockquote>
% javac GssServer.java
</blockquote></pre>
    </b> </li>
  <li>Read the following code. This is located in <a href="src/GssClient.java"><code>src/GssClient.java.</code></a>
<br><br>

This code fragment defines the action to execute after the client
principal has authenticated to the KDC. It replaces the <tt>MyAction</tt>
of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted
lines. The code first creates an instance of <b><code>GSSManager</code></b>
[line 10], which it uses to obtain a principal name for the service
that
it is going to communicate with [line 12]. It then creates an instance
of <b><code>GSSContext</code></b> [line 15,16] to perform
authentication [the loop between lines 22-33] with the service. Upon
completing authentication, it uses the established security context
to encrypt a message [line 42] and sends it to the server.
It then reads an encrypted message from the server and
decodes it using the established security context [line 53]. </li>
</ol>
Code listing for <code>GssClient.java</code>.<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>static class GssClientAction implements
PrivilegedExceptionAction {</code> </li>
        <li><code>...</code> </li>
        <li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create socket to server</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;Socket socket = new
Socket(hostName, port);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;DataInputStream inStream =
new DataInputStream(socket.getInputStream());</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;DataOutputStream outStream =
new DataOutputStream(socket.getOutputStream());</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get service's principal
name</code> </li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;GSSManager manager =
GSSManager.getInstance();</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;Oid krb5Oid = new
Oid("1.2.840.113554.1.2.2");</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<b>GSSName serverName =
manager.createName(serverPrinc, GSSName.NT_HOSTBASED_SERVICE);</b></code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get the context for
authentication</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;GSSContext context =
manager.createContext(serverName, krb5Oid, null,</code></strong></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
GSSContext.DEFAULT_LIFETIME);</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;context.requestMutualAuth(true);
// Request mutual authentication</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;context.requestConf(true); //
Request confidentiality</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Do the context
establishment loop</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] token = new byte[0];</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>context.isEstablished()</strong>)
{</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>token =
context.initSecContext(token, 0, token.length);</b></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check if we're
done</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!<b>context.isEstablished()</b>)
{</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token
= new
byte[inStream.readInt()];</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Context established!</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create MessageProp for use
with
unwrap (true means request confidentiality)</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;MessageProp prop = new
MessageProp(0, true);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create encrypted message
and send
to server</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] reply = ...;</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;token =
context.wrap(reply,
0, reply.length, prop);</code></strong></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;outStream.writeInt(token.length);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;outStream.write(token);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;outStream.flush();</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Read token from server</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;token = new
byte[inStream.readInt()];</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;inStream.readFully(token);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Unwrap (decrypt) token
sent by
server</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] input =
context.unwrap(token, 0, token.length, prop);</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;context.dispose();</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;socket.close();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code></li>
        <li><code>&nbsp;&nbsp;}</code></li>
        <li><code>}</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<ol start="4">

  <li>Compile the sample code. <b>
    <pre>
% javac GssClient.java
</pre></b> </li>

  <li>Launch a new window and start the server. <b>  
    <pre>
% xterm &amp;
% java -Djava.security.auth.login.config=jaas-krb5.conf \
       GssServer
</pre></b> </li>

  <li>Run the client application. <tt>GssClient</tt> takes two
parameters: the service name and the name of the server that the
service
is running on. For example, if the service is <b><code>host</code></b>
running on the machine <b><code>j1hol-001</code></b>, you would
enter the following. When prompted for the password, enter <b><tt>changeit</tt></b>.
    <b>   <pre>
    
% java -Djava.security.auth.login.config=jaas-krb5.conf \
       GssClient host j1hol-001
</pre>    </b> </li>

  <li>Observe the following output in the client and server
applications' windows.</li>
</ol>


<p>Output for running GssServer example.</p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>Authenticated principal:
[host/j1hol-001@J1LABS.EXAMPLE.COM]</code></li>
        <li><code>Waiting for incoming connections...</code></li>
        <li><code>Got connection from client /129.145.128.102</code></li>
        <li><code>Context Established!</code></li>
        <li><code>Client principal is test@J1LABS.EXAMPLE.COM</code></li>
        <li><code>Server principal is
host/j1hol-001@J1LABS.EXAMPLE.COM</code></li>
        <li><code>Mutual authentication took place!</code></li>
        <li><code>Received data "Hello There!" of length 12</code></li>
        <li><code>Confidentiality applied: true</code></li>
        <li><code>Sending: Hello There! Thu May 06 12:11:15 PDT 2005</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>


<p>Output for running GssClient example.</p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>Kerberos password for test: changeit</code></li>
        <li><code>Authenticated principal: [test@J1LABS.EXAMPLE.COM]</code></li>
        <li><code>Connected to address j1hol-001/129.145.128.102</code></li>
        <li><code>Context Established!</code></li>
        <li><code>Client principal is test@J1LABS.EXAMPLE.COM</code></li>
        <li><code>Server principal is host@j1hol-001</code></li>
        <li><code>Mutual authentication took place!</code></li>
        <li><code>Sending message: Hello There!</code></li>
        <li><code>Will read token of size 93</code></li>
        <li><code>Received message: Hello There! Thu May 06 12:11:15
PDT 2005</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<p><span style="font-family: helvetica,arial,sans-serif;"><span style="font-weight: bold; color: rgb(0, 0, 0); text-decoration: underline;">Summary:</span></span></p>

<P><span style="color: rgb(0, 0, 0);">In this exercise, you learned how to
write a client-server application that uses the Java GSS API to
authenticate and communicate securely with each other. </p>


<h3>Next Steps</h3>

<ol>
  <li>Proceed to <a href="#SASL">Exercise 4</a> to learn how to write a client/server application that uses the Java SASL API to authenticate and communicate securely with each other. </li>
  
  
  <li>Proceed to <a href="#JSSE">Exercise 5</a> to learn how to write a client/server application that uses the JSSE to authenticate and communicate securely with each other. </li>
  
  <li>Proceed to <a href="part3.html#SSO">Exercise 6</a> to learn how to
configure the sample programs that you have just used to achieve single sign-on in a Kerberos environment. </li>
</ol>

<hr>

<h2 class="main1"><a name="SASL"></a>Exercise 4: Using the Java SASL API<br>
</h2>


<h3>Goal of this exercise:</h3>

<P>
The goal of this exercise is to learn how to use the Java SASL API &nbsp;to perform secure authentication and communication.</p>


<h3>Background for this exercise:</h3>

<p>Simple Authentication
and Security Layer (SASL) specifies a challenge-response protocol in which data is exchanged between the client and the server for the
purposes of authentication and (optional) establishment of a security
layer on which to carry on subsequent communications. SASL allows
different <em>mechanisms</em> to be used; each such mechanism is
identified by a profile that defines the data to be exchanged and a
name. SASL is used with connection-based protocols such as LDAPv3 and
IMAPv4. SASL is described in <a href="http://www.ietf.org/rfc/rfc4422.txt">RFC 4422</a>.</p>


<p> The Java SASL API defines an API for applications to use SASL in a
mechanism-independent way. For example, if you are writing a library
for a networking protocol that uses SASL, you can use the Java SASL API
to generate the data to be exchanged with the peer. When the library is
deployed, you can dynamically configure the mechanisms to use with the
library. </p>


<p> In addition to authentication, you can use SASL to negotiate a
security layer to be used after authentication. But unlike the  GSS-API, the
properties of the security layer (such as whether you want integrity or
confidentiality) is decided at negotiation time. (the GSS-API allows
confidentiality to be turned on or off per message). </p>
<h3>Resources
for this exercise:</h3>



<ol>
  <li><a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/sasl/sasl-refguide.html">The
Java SASL API Programming and Deployment Guide</a></li>
  <li><a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/security/sasl/package-summary.html">The
Java SASL API javadocs</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4422.txt">Simple
Authentication
and Security Layer (SASL) (RFC 4422)</a><br>
  </li>
</ol>
<h3>Overview
of this exercise:</h3>


<p>This exercise
is a client-server application that demonstrates how to communicate
securely using the Java SASL API. The client and server parts first
authenticate to Kerberos using
<a href="part1.html#JAAS">Exercise 1</a>. This stores the credentials in the
subject.
The application then executes an action that performs Java SASL API
operations (with Kerberos as the underlying SASL mechanism)
inside of a <tt>Subject.doAs</tt> using the subject.
The SASL/Kerberos mechanism, because it is
executing inside the <tt>doAs</tt>, obtains the Kerberos credentials
from the subject, and uses them to authenticate with the peer
and to exchange messages securely.</p>

<p>
This example uses a simple protocol implemented by the <code><a href="src/AppConnection.java">AppConnection</a></code> class.
This protocol exchanges authentication commands and data commands.
Each command consists of a type (e.g., <tt>AppConnection.AUTH_CMD</tt>),
the length of the data to follow, and the data itself. The data is a
SASL buffer if it is for authentication or
encrypted/integrity-protected application data; it is plain application
data
otherwise.
</p>

</span>

<h3>Steps to follow:</h3> 

<ol>
  <li> Read the following code. This is located in <a href="src/SaslTestServer.java"><code>src/SaslTestServer.java.</code></a>
    <br><br> This code fragment defines the action to execute after the
service principal has authenticated to the KDC. It replaces the <tt>MyAction</tt>
of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted
lines. The server specifies the quality-of-protections that it will
support
[line 9] and then creates an instance of <b><tt>SaslServer</tt></b> to
perform
the authentication [line 21]. The challenge-response protocol of SASL
is
performed in the while loop [lines 33-49], with
the server sending challenges to the client and processing the
responses from
the client.
After authentication, the identity of the authenticated client
can be obtained via a call to <b><tt>getAuthorizedID()</tt></b> [line
61].
If a security layer was negotiated, the server can exchange data
securely
with the client [lines 66,70]. 
  </li>
</ol>
<p>Code listing for <code>SaslTestServer.java</code>.</p>

<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">

  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>static class SaslServerAction implements
PrivilegedExceptionAction {</code> </li>
        <li><code>...</code> </li>
        <li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create server socket for
accepting connections</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;ServerSocket ss = new
ServerSocket(localPort);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Support all
quality-of-protection options</code> </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;HashMap&lt;String,Object&gt;
props = new HashMap&lt;String,Object&gt;();</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;props.put(Sasl.QOP,
"auth-conf,auth-int,auth");</code></strong></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (true) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
application-level connection to handle request</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket socket =
ss.accept();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppConnection
conn = new AppConnection(socket);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Normally, the
application protocol will negotiate which</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// SASL mechanism
to use. In this simplified example, we</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// will always
use "GSSAPI" (the name of the mechanism that does Kerberos via GSS-API)</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create
SaslServer to perform authentication</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaslServer
srv = Sasl.createSaslServer("GSSAPI", service, serviceName, props, cbh);</code></strong></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (srv == null) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
... handle error</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read the
initial response from client</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] <strong>response</strong>
= conn.receive(AppConnection.AUTH_CMD);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppConnection.AppReply
clientMsg;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean auth =
false;</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Perform
authentication</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>srv.isComplete()</strong>)
{</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Generate challenge based on response</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
challenge = srv.evaluateResponse(response);</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(<strong>srv.isComplete()</strong>) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.send(AppConnection.SUCCESS,
          <strong>challenge</strong>);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auth
= true;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clientMsg
= conn.send(AppConnection.AUTH_IN_PROGRESS, <strong>challenge</strong>);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>response</strong>
= clientMsg.getBytes();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch (SaslException e) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Send failure notification to client</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.send(AppConnection.FAILURE,
null);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Authentication
completed!</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check status
of authentication</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<strong>srv.isCompleted()</strong>
&amp;&amp; auth) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("authorized
client is: " + <strong>srv.getAuthorizationID()</strong>);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
Report failure ... </code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Find out
whether security layer was negotiated</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String qop =
(String) <strong>srv.getNegotiatedProperty(Sasl.QOP)</strong>;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean sl =
(qop.equals("auth-conf") || qop.equals("auth-int"));</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Read and
decrypt message from client</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] msg =
conn.receive(AppConnection.DATA_CMD);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] realMsg =
(sl ? <strong>srv.unwrap(msg, 0, msg.length)</strong> : msg);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create and
encrypt message to send to client</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] reply =
...;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] realReply
= (sl ? <strong>srv.wrap(reply, 0, reply.length)</strong> : reply);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.send(AppConnection.SUCCESS,
realReply);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;}</code></li>
        <li><code>}</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<ol start="2">
  <li>Compile the sample code. <b>
  
    <pre>% javac SaslTestServer.java<br></blockquote></pre>
    </b> </li>
    
  <li>Read the following code. This is located in <a href="src/SaslTestClient.java">
  <code>src/SaslTestClient.java.</code></a>
This code fragment defines the action to execute after the client
principal has authenticated to the KDC. It replaces the <tt>MyAction</tt>
of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted
lines. The program first specifies the quality of protection
that it wants (in this case, confidentiality) [line 8] and
then creates an instance of <b><tt>SaslClient</tt></b> to use for
authentication [lines 11-12].
It then checks whether the mechanism has an initial response and if so,
gets the response by invoking <b><tt>evaluateChallenge()</tt></b>
with an empty byte array [line 20].
It then sends the response to the server to begin the authentication.
The challenge-response protocol of SASL is
performed in the while loop [lines 24-39], with
the client evaluating the challenges that it gets from the server
and sending the server the corresponding responses to the challenges.
After authentication, the client can proceed to communicate with the
server using the negotiated security layer [lines 48,55]. </li>
</ol>


<p>Code listing for <code>SaslTestClient.java</code>.</p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>static class SaslClientAction implements
PrivilegedExceptionAction {</code> </li>
        <li><code>...</code> </li>
        <li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create application-level
connection</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;AppConnection conn = new
AppConnection(serverName, port);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;HashMap&lt;String,Object&gt;
props = new HashMap&lt;String,Object&gt;();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>props.put(Sasl.QOP,
"auth-conf");</strong> // Request confidentiality</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create SaslClient to
perform authentication</code></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;SaslClient clnt =
Sasl.createSaslClient(</code></strong></li>
        <li><strong><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
String[]{"GSSAPI"}, null, service, serverName, props, cbh);</code></strong></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;if (clnt == null) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... handle
error</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] challenge;</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get initial response for
authentication</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>byte[] response =
clnt.hasInitialResponse() ? clnt.evaluateChallenge(EMPTY) : EMPTY;</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;AppConnection.AppReply reply
= conn.send(AppConnection.AUTH_CMD, response);</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Repeat until
authentication terminates</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (!<strong>clnt.isComplete()</strong>
&amp;&amp; </code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reply.getStatus()
== AppConnection.AUTH_INPROGRESS ||</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reply.getStatus()
== AppConnection.SUCCESS))</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Evaluate
challenge to generate response</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>challenge</strong>
= reply.getBytes()</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>response
= clnt.evaluateChallenge(challenge)</strong></code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(reply.getStatus() == AppConnection.SUCCESS) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(response != null) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new Exception("Protocol error")</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send response
to server and read server's next challenge</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reply =
conn.send(AppConnection.AUTH_CMD, <strong>response</strong>);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Authentication completed!</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Find out whether security
layer was negotiated</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;String qop = (String) <strong>srv.getNegotiatedProperty(Sasl.QOP)</strong>;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean sl =
(qop.equals("auth-conf") || qop.equals("auth-int"));</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] msg = ...;</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create and send encrypted
data to server</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] encrypted = (sl ? <strong>clnt.wrap(msg,
0, msg.length)</strong> : msg);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;reply =
conn.send(AppConnection.DATA_CMD, encrypted);)
{</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;...</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Read and decrypt data from
server</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] encryptedReply =
reply.getBytes();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;byte[] clearReply = (sl ? <strong>clnt.unwrap(encryptedReply,
0, encryptedReply.length)</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: encryptedReply);</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;conn.close();</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code></li>
        <li><code>&nbsp;&nbsp;}</code></li>
        <li><code>}</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>



<ol start="4">
  <li>Compile the sample code. <b>
  
    <pre>% javac SaslTestClient.java<br></blockquote></pre>
    </b> </li>
    
  <li>Launch a new window and start the server. <tt>SaslTestServer</tt>
takes two
parameters: the service name and the name of the server that the
service
is running on. For example, if the service is <b><code>host</code></b>
running on the machine <b><code>j1hol-001</code></b>, you would
enter the following. <b> 
    <pre>% xterm &amp;<br>% java <br> -Djava.security.auth.login.config=jaas-krb5.conf \<br>       SaslTestServer host j1hol-001<br></blockquote><br>    </pre>
    </b> </li>
  <li>Run the client application. <tt>SaslTestClient</tt> takes two
parameters: the service name and the name of the server that the
service
is running on. For example, if the service is <b><code>host</code></b>
running on the machine <b><code>j1hol-001</code></b>, you would
enter the following. When prompted for the password, enter <b><tt>changeit</tt></b>.
    <b> <code> </code>
    <pre><blockquote><br>% java -Djava.security.auth.login.config=jaas-krb5.conf \<br>       SaslTestClient host j1hol-001<br></blockquote></pre>
    </b> </li>
  <li>Observe the following output in the client and server
applications' windows.</li>
</ol>

<p>Output for running the <code>SaslTestServer</code> example. </p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>Authenticated principal:
[host/j1hol-001@J1LABS.EXAMPLE.COM]</code></li>
        <li><code>Waiting for incoming connections...</code></li>
        <li><code>Got connection from client /129.145.128.102</code></li>
        <li><code>Client authenticated; authorized client is:
test@J1LABS.EXAMPLE.COM</code></li>
        <li><code>Negotiated QOP: auth-conf</code></li>
        <li><code>Received: Hello There!</code></li>
        <li><code>Sending: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
        <li><code>Received data "Hello There!" of length 12</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>


<P>Output for running the <code>SaslTestClient</code> example.</p>



<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>Kerberos password for test: changeit</code></li>
        <li><code>Authenticated principal: [test@J1LABS.EXAMPLE.COM]</code></li>
        <li><code>Connected to address j1hol-001/129.145.128.102</code></li>
        <li><code>Client authenticated.</code></li>
        <li><code>Negotiated QOP: auth-conf</code></li>
        <li><code>Sending: Hello There!</code></li>
        <li><code>Received: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>


<ol start="8">
  <li>To try the program using different quality-of-protection, change
line 8 in <code>SaslTestClient</code>. For example, replace line 8
with the following line to use integrity protection on (no
confidentiality). <b>
<pre>props.put(Sasl.QOP, "auth-int");</pre>
</b> </li>

</ol>


<h3>Summary:</h3>


<p>In this exercise, you learned how to
write a client-server application that uses the Java SASL API to
authenticate and communicate securely with each other. </p>

<h3>Next Steps</h3>


<ol>
  <li>Proceed to <a href="#JSSE">Exercise 5</a> to learn how to write
a
client/server application that uses the JSSE to authenticate and
communicate securely with each other. </li>
  <li>Proceed to <a href="part3.html#SSO">Exercise 6</a> to learn how to
configure the sample programs that you have just used to achieve single
sign-on in a Kerberos environment. </li>
</ol>


<hr>


<h2><a name="JSSE"></a>Exercise 5: Using the Java Secure
Socket Extension with Kerberos
</h2>
<h3>Goal
of this exercise:</h3>

<p>
The goal of this exercise is to learn how to use the JSSE API
&nbsp;to perform secure authentication and communication using Kerberos cipher suites. </p>


<h3>Background
for this exercise:</h3>
<p>Secure
Socket Layer (SSL) and Transport Layer Security (TLS) are the
most widely used protocols for implementing cryptography on the
Internet. TLS is the Internet standard evolved from SSL. SSL/TLS
provides application-level protocols (such as HTTP and LDAP) with
secure authentication and communication. For example, HTTPS is the
resulting protocol of using HTTP over SSL/TLS.
SSL/TLS is used not only for
standard protocols such as HTTP, it is also widely used when building
custom applications using custom protocols that need to communicate
securely. </p>


<p>SSL/TLS traditionally used certificate-based authentication and is
commonly used for server-authentication. For example, when a Web
client such as a browser accesses a secure Web site (server) on behalf
of a user, the server sends its certificate to the browser so that the
browser can verify the identity of the server. This ensures
that the user does
not divulge confidential information (such as credit card information)
to a bogus server. Recently, a new standard allows the use of Kerberos
with TLS. This means instead of using certificate-based
authentication, an application can use Kerberos credentials and take
advantage of the Kerberos infrastructure in the deployment
environment. Using Kerberos cipher suites also provides automatic
support for mutual authentication in which the client is also
authenticated in addition to the server.
</p>
<p>
The decision of whether to use Java GSS, Java SASL, or JSSE for a
particular application often depends upon several factors, including
(the protocols being used by) the services with
which the application interacts, the deployment environment (PKI or
Kerberos-based), and the application's security requirements.
JSSE provides a secure end-to-end channel that takes care of the I/O
and transport, while Java GSS and Java SASL provide encryption
and integrity-protection on the data, but the application is
responsible for transporting the secured data to its peer.
Some details about factors for deciding when to use JSSE versus
Java GSS are presented in the document,
<a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/jgss/tutorials/JGSSvsJSSE.html">When
to use Java GSS vs. JSSE</a>. </p>

<h3>Resources
for this exercise:</h3>


<ol>
  <li><a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/jsse/JSSERefGuide.html">Java
Secure Socket Extension (JSSE) Reference Guide</a></li>
  <li>The JSSE javadocs: <tt><a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/net/package-summary.html">javax.net</a></tt>
and <a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/net/ssl/package-summary.html">javax.net.ssl</a></li>
  
<li><a href="http://wp.netscape.com/eng/ssl3/ssl-toc.html">The SSL
Protocol version 3.0</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc2246.txt">The TLS Protocol
Version 1.0 (RFC 2246)</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc2712.txt">Addition of
Kerberos Cipher Suites to Transport Layer Security TLS (RFC 2712)</a> </li>
  <li> <a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/jgss/tutorials/JGSSvsJSSE.html">When
to use Java GSS vs. JSSE</a> </li>
</ol>


<h3>Overview
of this exercise:</h3>



<p>This exercise
is a client-server application that demonstrates how to communicate
securely using the JSSE and Kerberos cipher suites.
The client and server parts first authenticate to Kerberos using
<a href="part1.html#JAAS">Exercise 1</a>. This stores the credentials in the
subject.
The application then executes an action that performs JSSE
operations (using a Kerberos cipher suite)
inside of a <tt>Subject.doAs</tt> using the subject.
The Kerberos cipher suite implementation, because it is
executing inside the <tt>doAs</tt>, obtains the Kerberos credentials
from the subject, and uses them to authenticate with the peer
and to exchange messages securely.
This example sends newline-terminated messages, encrypted using
the negotiated cipher suite and integrity-protected,
back and forth between client and server.
</p>
<p>According to the standard (RFC 2712)
all Kerberos-enabled TLS applications use the same service name,
namely,
<b>"host"</b>. That is why in this exercise, you do not need to
explicitly
supply the Kerberos service name.
</p>
</span>
<h3>Steps
to follow:</h3>



<ol>
  <li> Read the following code. This is located in <a href="src/JsseServer.java"><code>src/JsseServer.java</code></a>
    <br><br> This code fragment defines the action to execute after the
service principal has authenticated to the KDC. It replaces the <tt>MyAction</tt>
of line 11 of <a href="part1.html#JAAS">Exercise 1</a>. Note the highlighted
lines. The server first creates an <strong><tt>SSLServerSocket</tt></strong>
[lines 5-8]. This is analogous to an application creating a plain <tt>ServerSocket</tt>
except an <tt>SSLServerSocket</tt> will
provide
automatic authentication, encryption and decryption, as needed.
The server then sets the cipher suites that it wants to use [lines
11-12]. The server then runs in a loop, accepting
connections from SSL clients [line 17], and reads and writes from
the SSL socket [lines 23, 28]. The server can find out the identities
of the
owners of socket by invoking the <strong><tt>getLocalPrincipal()</tt></strong>
and <strong><tt>getPeerPrincipal()</tt></strong> methods [lines
32-33]. </p>
  </li>
</ol>


<p>Code listing for <code>JsseServer.java</code>.</p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>static class JsseServerAction implements
PrivilegedExceptionAction {</code> </li>
        <li><code>...</code> </li>
        <li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create TLS socket for
accepting connections</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLServerSocketFactory
sslssf =</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>(SSLServerSocketFactory)
SSLServerSocketFactory.getDefault();</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLServerSocket
sslServerSocket =</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>(SSLServerSocket)
sslssf.createServerSocket(localPort);</strong></code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Enable only a Kerberos
cipher suite </code> </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;String enabledSuites[] = {
"TLS_KRB5_WITH_3DES_EDE_CBC_SHA" };</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslServerSocket.setEnabledCipherSuites(enabledSuites);</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Should handle exception if
enabledSuites is not supported</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;while (true) {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create socket
to handle request</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLSocket
sslSocket = (SSLSocket) sslServerSocket.accept();</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader in
= new BufferedReader(new InputStreamReader(</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getInputStream()</strong>));</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedWriter
out = new BufferedWriter(new OutputStreamWriter(</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getOutputStream()</strong>));</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String inStr = <strong>in.readLine()</strong>;
          </code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ... use inStr</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Compose and
send reply</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String outStr =
inStr + " " + new Date().toString() + "\n";</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>out.write(outStr);</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.flush();</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Get names of
principal at both ends of secure connection</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal
self = sslSocket.getSession().getLocalPrincipal();</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal
peer = sslSocket.getSession().getPeerPrincipal();</strong></code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.close();</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></li>
        <li><code>&nbsp;&nbsp;}</code></li>
        <li><code>}</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<ol start="2">
  <li>Compile the sample code. <b><code></code>
    <pre><blockquote><br>% javac JsseServer.java<br></blockquote></pre>
    </b> </li>
  <li>Read the following code. This is located in <a href="src/JsseClient.java"><code>src/JsseClient.java</code></a>.
This code fragment defines the action to execute after the client
principal has authenticated to the KDC. It replaces the <tt>MyAction</tt>
of line 11 of <a href="#JAAScode">Exercise
1</a>. Note the highlighted lines. The client first creates an <tt><strong>SSLSocket</strong></tt>.
The client then sets the
cipher
suites that it wants to use [lines 11-12]. The client then exchanges
messages with the server using the <tt>SSLSocket</tt> by reading and
writing to the socket's
input/output
streams. The client can find out the identities of the
owners of socket by invoking the <strong><tt>getLocalPrincipal()</tt></strong>
and <strong><tt>getPeerPrincipal()</tt></strong> methods [lines
26-27]. </li>
</ol>


<p>Code listing for <code>JsseClient.java</p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>static class JsseClientAction implements
PrivilegedExceptionAction {</code> </li>
        <li><code>...</code> </li>
        <li><code>&nbsp;&nbsp;public Object run() throws Exception {</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Create SSL connection</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLSocketFactory
sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>SSLSocket sslSocket =
(SSLSocket) sslsf.createSocket(server, port);</strong></code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Enable only a Kerberos
cipher suite </code> </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;String enabledSuites[] = {
"TLS_KRB5_WITH_3DES_EDE_CBC_SHA" };</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.setEnabledCipherSuites(enabledSuites);</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Should handle exception if
enabledSuites is not supported</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;BufferedReader in = new
BufferedReader(new InputStreamReader(</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getInputStream()</strong>));</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;BufferedWriter out = new
BufferedWriter(new OutputStreamWriter(</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.getOutputStream()</strong>));</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;String outStr = ...;</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>out.write(outStr);</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;out.flush();</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;String inStr = <strong>in.readLine()</strong>;
          </code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// ... use inStr</code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;// Get names of principal at
both ends of secure connection</code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal self =
sslSocket.getSession().getLocalPrincipal();</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Principal peer =
sslSocket.getSession().getPeerPrincipal();</strong></code></li>
        <li><br>
        </li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;<strong>sslSocket.close();</strong></code></li>
        <li><code>&nbsp;&nbsp;&nbsp;&nbsp;return null;</code></li>
        <li><code>&nbsp;&nbsp;}</code></li>
        <li><code>}</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>


<ol start="4">
  <li>Compile the sample code. <b>
    <pre>% javac JsseClient.java<br></pre>
    </b> </li>
    
  <li>Launch a new window and start the server. <tt>JsseServer</tt>
takes one
parameter: the name of the server that the JSSE service
is running on. For example, if it is
running on the machine <b><code>j1hol-001</code></b>, you would
enter the following. <b> 
    <pre>% xterm &amp;<br>% java <br> -Djava.security.auth.login.config=jaas-krb5.conf \<br>       JsseServer j1hol-001<br></blockquote><br>    </pre>
    </b> </li>
    
    
  <li>Run the client application. <tt>JsseClient</tt> takes one
parameter: the name of the server that the JSSE service
is running on. For example, if the service is
running on the machine <b><code>j1hol-001</code></b>, you would
enter the following. When prompted for a password, enter <b><tt>changeit</tt></b>.
    <b> <code> </code>
    <pre><blockquote><br>% java -Djava.security.auth.login.config=jaas-krb5.conf \<br>       JsseClient j1hol-001<br></blockquote></pre>
    </b> </li>
  <li>Observe the following output in the client and server
applications' windows.</li>
</ol>

<p>Output for running the <code>JsseServer</code> example.</p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>Authenticated principal:
[host/j1hol-001@J1LABS.EXAMPLE.COM]</code></li>
        <li><code>Waiting for incoming connections...</code></li>
        <li><code>Got connection from client /129.145.128.102</code></li>
        <li><code>Received: Hello There!</code></li>
        <li><code>Sending: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
        <li><code>Cipher suite in use: TLS_KRB5_WITH_3DES_EDE_CBC_SHA</code></li>
        <li><code>I am: host/j1hol-001@J1LABS.EXAMPLE.COM</code></li>
        <li><code>Client is: test@J1LABS.EXAMPLE.COM</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>

<p>Output for running the <code>JsseClient</code> example.</p>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"> <br>
      <ol>
        <li><code>Kerberos password for test: changeit</code></li>
        <li><code>Authenticated principal: [test@J1LABS.EXAMPLE.COM]</code></li>
        <li><code>Sending: Hello There!</code></li>
        <li><code>Received: Hello There! Fri May 07 15:32:37 PDT 2005</code></li>
        <li><code>Cipher suite in use: TLS_KRB5_WITH_3DES_EDE_CBC_SHA</code></li>
        <li><code>I am: test@J1LABS.EXAMPLE.COM</code></li>
        <li><code>Server is: host/j1hol-001@J1LABS.EXAMPLE.COM</code></li>
      </ol>
      <br>
      </td>
    </tr>
  </tbody>
</table>


<h3>Summary:</h3>


<p>In this exercise, you learned how to
write a client-server application that uses JSSE to
authenticate and communicate securely with each other, using Kerberos
as the underlying authentication system. <p>

<h3>Next Steps</h3>


<ol>
  <li>Proceed to <a href="part3.html#SSO">Exercise 6</a> to learn how to
configure the sample programs in Exercises 3, 4, and 5 to achieve
single
sign-on in a Kerberos environment. </li>
</ol>

<hr>

</body></html>
